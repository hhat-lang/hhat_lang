{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"H-hat quantum language","text":"<p>Warning</p> <p>This is a work in progress and may be seeing as such. Errors, inconsistencies, tons of experimentation, modifications and trials are happening. Until there is a stable version, it is prone to breaking changes.</p>"},{"location":"#what-h-hat-is","title":"What <code>H-hat</code> is","text":"<ul> <li>A quantum programming language family and the ecosystem to build it</li> <li>An abstraction layer above QASM-like languages</li> <li>A language to<ul> <li>Use higher-level abstraction to harness quantum resources, such as superposition,   entanglement, etc.</li> <li>Need no specialized knowledge on quantum mechanics or quantum information theory</li> <li>Close the gap between developers/programmers/computer scientists and quantum physicists</li> <li>Use quantum data and quantum data structures to reason about quantum information processing</li> <li>Solve problems using quantum logic, rather than Quantum Mechanics approach</li> </ul> </li> </ul>"},{"location":"#what-h-hat-is-not","title":"What <code>H-hat</code> is not","text":"<ul> <li>A replacement for quantum logic-level quantum computation (circuit-like quantum computing, for   instance), such as QASM-like languages</li> <li>A full stack programming language with direct access to the hardware</li> <li>A simulator</li> <li>A replacement for Quantum Mechanics</li> </ul>"},{"location":"#language-features","title":"Language features","text":"<ul> <li>Code reasoning closer to classical programming languages</li> <li>Quantum data types, variables, functions just as its classical counterpart</li> <li>Additionally, there is quantum primitives to define some general platform-dependent instruction   set</li> <li>Classical and quantum parts have similar syntaxes and components</li> <li>Quantum variables:<ul> <li>hold quantum and classical instructions</li> <li>execute its content and perform measurement once a <code>cast</code> function is called upon it</li> <li>re-execute the same data content every time it is cast</li> </ul> </li> <li>Platform- and quantum logic language- independent</li> <li>Can hold many syntaxes/dialects implementations to work in harmony with each other</li> </ul>"},{"location":"#code-organization","title":"Code Organization","text":"<p>The code is organized by the development language chosen to develop H-hat, also known as main development language (MDL). For instance, a <code>python/</code> folder will contain <code>Python</code> code to make a workable version of H-hat, as a <code>rust/</code> folder will contain a respective <code>Rust</code> code. Each programming language development folder must reproduce the same results regardless the language chosen. It means different MDLs will converge on the expected behavior and a H-hat code should work in any of those implementations.</p>"},{"location":"#current-mdls","title":"Current MDLs","text":"<p>Some MDLs are being actively developed and have their own branch. For example, development branch for <code>Python</code> MDL is in dev/python, while in progress branch should be in <code>dev/python_impl/[custom_name]</code>. Once stable, their folders should appear in the main branch.</p>"},{"location":"#how-to-use-h-hat","title":"How to use H-hat","text":"<p>Note</p> <p>The development is still in alpha phase, but some features are being released in different MDLs to test concepts, functionalities, feasibility and performance.</p> <p>Each MDL folder (for example <code>python/</code>) will contain more information about their implementation as well as how to install and/or start coding with H-hat. You may want to look directly into the folder of your preferred (available) programming language.</p>"},{"location":"#h-hat-heather","title":"H-hat Heather","text":"<p>H-hat defines some rules and concepts to its paradigm so programmers can understand how to use it. However, it does not explicitly implement a particular syntax or interpreter/JIT/compiler. The main idea is to give programmers freedom to develop their own syntax and/or interpreter/compiler versions that are compatible with those rules.</p> <p>To showcase some features and present programmers with its paradigm, a dialect is developed, called Heather. It is a simple dialect with simple syntax that can make concrete what programming a H-hat code should/does look like. You may find its implementation in some of the MDL folders as <code>[MDL]/dialects/heather/</code> (ex: <code>python/dialects/heather/</code>).</p> <p>New reference dialects may emerge in the future.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Finally, you can get started by checking out the Getting Started page.</p>"},{"location":"#license","title":"License","text":"<p>MIT</p>"},{"location":"#how-to-contribute","title":"How to Contribute","text":"<p>Important</p> <p>Please read this documentation before to understand how the repository is organized and how the language structure works.</p> <p>You can check the TODOs.md page to see what is listed to be done. There (probably) are issues in the H-hat issue's page that you may want to check and try to solve/implement as well. </p> <p>At last, reach us out at the Discord's <code>#h-hat</code> channel to learn more on how to contribute and chat, if you feel like doing so.</p>"},{"location":"#code-of-conduct","title":"Code of Conduct","text":"<p>We coexist in the same world. So be nice to others as you expect others to be nice to you :)</p>"},{"location":"TODOs/","title":"TODOs","text":"<p>Here sits an updated list of things to implement/write. Feel free to check them out and place an issue or discuss them at the Discord's <code>#h-hat</code> channel.</p>"},{"location":"TODOs/#h-hat-core-modules","title":"H-hat core modules","text":""},{"location":"TODOs/#memory","title":"Memory","text":"<ul> <li> create scope data structure for stack and heap</li> <li> define scopes:<ul> <li> <code>0</code> scope for global scope</li> <li> <code>main</code> for main scope</li> <li> function name with an extra identifier for their respective scope</li> <li> make sure the current scope can only have access to <code>0</code> and its current memory scopes</li> </ul> </li> <li> implement writing to, reading from and removing from stack<ul> <li> on the same scope</li> <li> from a function exit back to the previous scope</li> </ul> </li> <li> implement writing to, reading from and removing from heap<ul> <li> on the scope</li> </ul> </li> <li> implement freeing memory (when scope is... out of scope)</li> </ul>"},{"location":"TODOs/#types","title":"Types","text":"<ul> <li> implement casting from quantum types to classical types</li> <li> implement casting from generic literals to specific literals, e.g. <code>156</code> to <code>u32</code> or <code>@2</code> to <code>@u3</code>, etc.</li> </ul>"},{"location":"TODOs/#error-handlers","title":"Error handlers","text":""},{"location":"TODOs/#execution","title":"Execution","text":""},{"location":"TODOs/#low-level","title":"Low level","text":"<ul> <li> implement protocol class to interpret the result from quantum data execution into a specific classical data type</li> <li> implement conversion class to cast quantum data to classical data</li> </ul>"},{"location":"TODOs/#configurations","title":"Configurations","text":"<ul> <li> Implement configuration handler<ul> <li> read from file (json? yaml? toml?)</li> <li> write to file</li> <li> choose the settings to hold<ul> <li> target backend<ul> <li> name</li> <li> version</li> <li> device type: simulator, QPU</li> <li> execution type: local, remote</li> <li> maximum number of qubits</li> <li> low level language(s) supported</li> <li> execution type: static, dynamic (supports mid-circuit measurement)</li> </ul> </li> </ul> </li> <li> transform settings into respective functions/classes (dynamic import)</li> </ul> </li> </ul>"},{"location":"TODOs/#heather-dialect","title":"Heather dialect","text":""},{"location":"TODOs/#code","title":"code","text":""},{"location":"TODOs/#parsing","title":"parsing","text":"<ul> <li> implement visitor/parser using Heather's AST and grammar</li> </ul>"},{"location":"TODOs/#simple-ir-builder","title":"simple IR builder","text":"<ul> <li> finish implementing the transformation of AST into IR</li> </ul>"},{"location":"TODOs/#interpreter","title":"interpreter","text":"<ul> <li> either remove or give a real purpose for <code>interpreter.executor.Evaluator</code></li> </ul>"},{"location":"TODOs/#classical","title":"classical","text":"<ul> <li> finish implementing the <code>interpreter.classical.executor.Evaluator</code></li> </ul>"},{"location":"TODOs/#quantum","title":"quantum","text":"<ul> <li> connect the quantum computation result with the protocol and conversion class from the chosen classical data type and put the result into the current scope stack</li> </ul>"},{"location":"TODOs/#low-level-core","title":"Low level core","text":""},{"location":"TODOs/#quantum-languages","title":"Quantum languages","text":"<ul> <li> OpenQASM v2<ul> <li> implement instructions<ul> <li> if</li> <li> @not</li> <li> @redim</li> <li> @sync</li> <li> @if</li> </ul> </li> <li> <code>LowLevelQLang</code><ul> <li> includes mid-circuit measurements</li> <li> implement <code>CompositeSymbol</code></li> <li> implement <code>CompositeLiteral</code></li> <li> implement <code>CompositeMixData</code></li> <li> implement fallback to H-hat dialect execution on classical code when openQASMv2 does not support the code</li> </ul> </li> </ul> </li> </ul>"},{"location":"TODOs/#quantum-target-backends","title":"(Quantum) Target backends","text":"<ul> <li> <code>qiskit</code><ul> <li> change the backend name to <code>ibm</code>?</li> <li> include a generic way to fetch the correct backend (right now <code>AerSimulator</code> is hardcoded, but it can be any available local or remote simulator or QPU)</li> </ul> </li> </ul>"},{"location":"TODOs/#toolchain","title":"Toolchain","text":""},{"location":"TODOs/#project","title":"project","text":"<ul> <li> implement <code>run</code> module to execute a code</li> </ul>"},{"location":"TODOs/#cli","title":"CLI","text":"<ul> <li> implement CLI functionalities using the <code>toolchain.project</code> module<ul> <li> <code>new project</code></li> <li> <code>update</code></li> <li> <code>run</code></li> </ul> </li> </ul>"},{"location":"TODOs/#documentation","title":"Documentation","text":"<ul> <li> Describe:<ul> <li> rule system</li> <li> core code features</li> <li> cli</li> <li> notebooks</li> <li> dialect creation tools/API</li> <li> Language ecosystem</li> <li> Heather syntax</li> <li> Heather language features</li> </ul> </li> </ul>"},{"location":"cli/","title":"CLI","text":"<p>In progress. This section is part of a TODO list.</p>"},{"location":"getting_started/","title":"Getting Started","text":"<p>Currently, H-hat is toolchain and development language system only available through third-party languages, such as Python and Rust. For more information, please check the Python and Rust pages.</p>"},{"location":"getting_started/#installation","title":"Installation","text":"<ul> <li>Python guide</li> <li>Rust guide</li> </ul>"},{"location":"notebooks/","title":"Notebooks","text":"<p>In progress. This section is part of a TODO list.</p>"},{"location":"rule_system/","title":"Rule System","text":"<p>In progress. This section is part of a TODO list.</p>"},{"location":"running_hhat/","title":"Running H-hat","text":""},{"location":"running_hhat/#with-cli","title":"With CLI","text":"<p>In development</p> <p>This step is not implemented yet and sits in a TODO list to be done.</p> <p>With the CLI configured and installed, it can be used on the terminal through the <code>hat</code> command.</p> <pre><code>hat --help\n</code></pre> <p>For more information on commands available.</p>"},{"location":"running_hhat/#with-python-currently-available","title":"With Python currently available","text":"<p>In progress</p> <p>This step is in progress, so you may experience some breaking or incomplete parts. </p> <p>The project file organization is created as follows:</p> <pre><code>project_name/\n\u251c\u2500 src/\n\u2502  \u251c\u2500 hat_types/\n\u2502  \u251c\u2500 hat_docs/\n\u2502  \u2502  \u251c\u2500 hat_types/\n\u2502  \u2502  \u2514\u2500 main.hat.md\n\u2502  \u2514\u2500 main.hat\n\u2514\u2500 tests/\n</code></pre> <p>Using H-hat library, one can access it through the <code>hhat_lang.toolchain.cli</code> module.</p>"},{"location":"running_hhat/#creating-a-new-project","title":"Creating a new project","text":"<pre><code>from hhat_lang.toolchain.cli import new\n\nnew.create_new_project(\"new_project\")\n</code></pre> <p>This will create a new project called <code>new_project</code>, with all the folders and auxiliary tools to enable start developing in H-hat with the select dialect .</p>"},{"location":"running_hhat/#creating-a-new-file","title":"Creating a new file","text":"<p>A new file can be created through:</p> <pre><code>new.create_new_file(\"new_project\", \"file_name\")\n</code></pre> <p>This will create a <code>file_name.hat</code> file into the <code>new_project</code> project, as well as a <code>file_name.hat.md</code> file at <code>hat_docs/</code>. For every file, there will be a documentation file.</p> <p>New type files are created slightly different:</p> <pre><code>new.create_new_type_file(\"new_project\", \"file_type\")\n</code></pre> <p>It will create a <code>file_type.hat</code> at <code>hat_types/</code>, as well as its documentation counterpart at the <code>hat_docs/hat_types/file_type.hat.md</code>.</p>"},{"location":"running_hhat/#with-rust","title":"With Rust","text":"<p>Unavailable</p> <p>This step is currently unavailable. May be implemented in the future.</p>"},{"location":"toolchain/","title":"Toolchain","text":"<p>The tools available for H-hat are the following:</p> <ul> <li>Dialect creation: the most important features that identifies a programming language as part of H-hat family are present there, and can be incorporated and extended within your own dialect.</li> <li>Commandline interface (CLI): the commands you can use to create a new project, update it, include code documentation, execute a project code, access notebooks for interactive code, etc.</li> <li>Notebooks: write your code in an interactive way through Jupyter notebooks.</li> </ul>"},{"location":"core/","title":"Core Features","text":"<p>In progress. This section is part of a TODO list.</p>"},{"location":"dialects/","title":"H-hat Dialects","text":"<p>Dialects are independent programming languages that share some common features, as defined by H-hat rule system. Although they may be syntactically different, their essence in those rules must be the same.</p> <p>To enable experiencing what H-hat proposes, a first H-hat dialect was created, called Heather.</p>"},{"location":"dialects/creation/","title":"Dialect creation","text":"<p>In progress. This section is part of a TODO list.</p>"},{"location":"dialects/heather/","title":"H-hat's Heather dialect","text":"<p>The name is twofold: a plant<sup>1</sup> and a song<sup>2</sup>. There is no especial reason behind the name besides the author enjoyment for the song.</p>"},{"location":"dialects/heather/#introduction","title":"Introduction","text":"<p>This dialect was developed to enable programmers to experience H-hat rule system and explore ideas for a new quantum computer science theory that intends to focus more on the computer science of the thing, namely manipulate quantum data rather than quantum states. </p>"},{"location":"dialects/heather/#features","title":"Features","text":"<ul> <li>Statically typed: data must have a defined type, and it includes variables</li> <li>No statements separator: there is no obligatory separator between statements, such as semicolon (<code>;</code>), but you are free to use it.</li> <li>Whitespaces: the dialect whitespaces are:<ul> <li>space, tab <code>\\t</code>, newline <code>\\n</code>, semicolon <code>;</code>, and comma <code>,</code></li> </ul> </li> <li>Quantum data starts with the <code>@</code> character: this includes variables, literals, functions and types.</li> </ul> <ol> <li> <p>Scientific name: Calluna vulgaris, a small flowering shrub.\u00a0\u21a9</p> </li> <li> <p>Billy Cobham's Crosswinds album, second track of side two.\u00a0\u21a9</p> </li> </ol>"},{"location":"dialects/heather/current_syntax/","title":"Syntax","text":"<p>Note</p> <p>The syntax is in development and will have more features added continuously.</p> <p>The H-hat's Heather dialect syntax works as follows:</p> <ol> <li> <p>There is a main file that will be used for program execution. Its name can be anything, but it must contain a <code>main</code> keyword with brackets:</p> <pre><code>main {}\n</code></pre> </li> <li> <p>Code to be executed must live inside <code>main</code> body, e.g. anything inside the brackets will be executed.</p> </li> <li>Comments are:<ul> <li><code>// comment here</code> for oneliner</li> <li><code>/- big comment here... -/</code> for multiple lines</li> </ul> </li> <li>Variable declaration:    <pre><code>var:type    // for classical data\n\n@var:@type  // for quantum data\n</code></pre></li> <li>Variable assignment:    <pre><code>// classical\nvar1:type = value     // declare+assign\nvar2 = value          // assign\n\n// quantum\n@var1:@type = @value  // declare+assign\n@var2 = @value        // assign\n</code></pre></li> <li>Call:    <pre><code>do_smt()               // empty call\nprint(\"hoi\")           // one-argument call\nadd(1 2)               // multiple-anonymous argument call\nrange(start:0 end:10)  // multiple-named argument call\n</code></pre><ul> <li>Multiple-argument call arguments can be separated by any Heather-defined whitespaces</li> <li>Calls with named argument will have the <code>argument-name</code> followed by colon <code>:</code> and its value, e.g. <code>arg:val</code></li> </ul> </li> <li>Classical variable assignment:    <pre><code>var:type = data    // assign value\nvar = other-data   // assign a new data\n</code></pre><ul> <li>Assigning data more than once to a classical variable may be possible if it is mutable. More on that at the language core system page. If the variable is immutable, an error will happen.</li> </ul> </li> <li>Quantum variable assignment:    <pre><code>@var:@type = @first_value  // assign the first value\n@fn(@var)                  // @fn will be appended to @var data\n@other-fn(@var params)     // @other-fn will be appended next\n</code></pre><ul> <li>A quantum data is an appendable data container, that is a data container that appends instructions applied to it in order. In the case above, the content of <code>@var</code> will be an array of elements: <code>[first_value, @fn(%self), @other-fn(%self params)]</code> that will be transformed and executed in order. More on what appendable data container is at the language core system page.</li> </ul> </li> <li>Casting:    <pre><code>// classical data to classical data casting\nu32*16      // casts 16 to u32 type\n\n// quantum data to classical data casting\nu32*@2      // casts @2 to u32 type\n</code></pre><ul> <li>Casting is a special property in the H-hat logic system. There is the usual classical to classical data casting, but also the quantum to classical data casting. The quantum to classical is special due to the nature of quantum data/variables. More on that in the rule system page. The syntax is <code>type*literal</code> or <code>type*variable</code>. In a similar fashion when declaring a variable one uses <code>variable:type</code>, it can be thought as the \"other way around\" process, that is why it was chosen to define the type first on casting (with a different syntax sugar, <code>*</code>, to connect the type with the data).</li> </ul> </li> </ol>"},{"location":"dialects/heather/heather_syntax/","title":"\\(\\hat{H}\\)'s Heather dialect syntax","text":""},{"location":"dialects/heather/heather_syntax/#importing-types","title":"Importing types","text":"<p>To enable a type contained in the <code>hhat_types/</code> folder:</p> <pre><code>use(type:point)\n</code></pre> <p>for more than one type:</p> <pre><code>use(type:[point point3d])\n</code></pre> <p>for types in nested folders (<code>scalar/</code> in the example below) inside <code>hhat_types/</code> folder:</p> <pre><code>use(type:[scalar.pos scalar.velocity scalar.acceleration])\n</code></pre> <p>or</p> <pre><code>use(type:[scalar.{pos velocity acceleration}])\n</code></pre> <p>Note: Incorporating external types downloaded from a valid collection repository or from another local project is still in design phase.</p>"},{"location":"dialects/heather/heather_syntax/#importing-functions","title":"Importing functions","text":"<p>To enable a function in the project:</p> <pre><code>use(fn:sum)\n</code></pre> <p>for more than one function:</p> <pre><code>use(fn:[sum times safe-div])\n</code></pre> <p>for functions inside nested folders (<code>linalg/</code> in the example below) on <code>src/</code> folder:</p> <pre><code>use(fn:[linalg.dot linalg.inner linalg.outer])\n</code></pre> <p>or</p> <pre><code>use(fn:[linalg.{dot inner outer}])\n</code></pre> <p>and</p> <pre><code>use(\n    fn:[\n        linalg.{\n            dot\n            inner\n            outer\n        }\n        stats.{\n            rv-continuous:rvc\n            rv-discrete:rvd\n        }\n    ]\n)\n</code></pre> <p>where <code>rvc</code> is the label for <code>stats.rv-continuous</code> and <code>rvd</code> is the label for <code>stats.rv-discrete</code> function, respectively.</p> <p>Note: Incorporating external functions from downloaded sources or local project is still on design phase.</p>"},{"location":"python/python_guide/","title":"Python","text":"<p>To properly and safely install H-hat on your computer, you need to configure a Python virtual environment. You can choose between various packages, including venv, hatch, uv, pdm, and poetry. </p> <p>After configuring it, activate it (each package has their own way to do it, please check it out before proceeding), and choose one of the methods below to install <code>H-hat</code>:</p>"},{"location":"python/python_guide/#via-pypi","title":"Via Pypi","text":"<p>Note</p> <p><code>hhat-lang</code> library might be out-of-date compared to the source code method below.</p> <p>This is the easiest, most straightforward and simplest way to install <code>H-hat</code>. On the terminal, with the virtual environment enabled, type:<sup>1</sup></p>"},{"location":"python/python_guide/#if-you-are-using-bash-shell","title":"If you are using <code>bash</code> shell:","text":"<pre><code>pip install hhat-lang .[all]\n</code></pre>"},{"location":"python/python_guide/#if-you-are-using-zsh-shell","title":"If you are using <code>zsh</code> shell:","text":"<pre><code>pip install hhat-lang \".[all]\"\n</code></pre> <p>Either the options above will install all the tools, features and a H-hat dialect called Heather so you can start learning and writing your own code.</p>"},{"location":"python/python_guide/#via-source-code-recommended","title":"Via source code recommended","text":"<p>Use the clone HTTPS link in the H-hat repository page and git clone it, using the terminal:</p> <pre><code>git clone https://github.com/hhat-lang/hhat_lang.git\n</code></pre> <p>This will create the <code>hhat_lang/</code> folder with all the code content, where you can pip install through the editable mode:</p>"},{"location":"python/python_guide/#if-you-are-using-bash-shell_1","title":"If you are using <code>bash</code> shell:","text":"<pre><code>pip install -e .[all]\n</code></pre>"},{"location":"python/python_guide/#if-you-are-using-zsh-shell_1","title":"If you are using <code>zsh</code> shell:","text":"<pre><code>pip install -e \".[all]\"\n</code></pre> <p>Note</p> <p>This approach is meant to be used for those who want to modify the code.</p> <ol> <li> <p>How to check which shell I am using?\u00a0\u21a9</p> </li> </ol>"},{"location":"rust/rust_guide/","title":"Rust","text":"<p>The Rust guide is not yet available.</p>"}]}